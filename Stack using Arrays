#include<iostream>
#include<algorithm>
#include<vector>
#include<sstream>
#include<queue>
#include<cmath>
#include<iomanip>
#include<set>
#include<map>
using namespace std;
#define ll long long
#define pb push_back
#define pll pair<ll,ll> 
#define mll map<ll,ll>
#define pii pair<int,int>
#define vpii vector<pii>
#define rep(i,n) for(int i=0; i<n; i++)
#define All(x,v) for(auto x:v)
#define arrin(a,n) ll a[n]; rep(i,n) cin>>a[i]
#define vi vector<int>
#define vll vector<ll>
#define nl "\n"
#define print(arr) All(x,arr) cout<<x<<" "; cout<<nl
#define sz(x) (int)x.size()
#define all(v) v.begin(),v.end()
#define ing(m,ad) rep(i,m){ int u,v; cin>>u>>v; u--;v--; ad[u].pb(v); ad[v].pb(u);}
#define vdsort(v) sort(v.begin(),v.end(),greater<int>())
#define F first
#define S second
#define mod 1'000'000'007
const int MAXN = 100'005;
int spf[MAXN];
ll fac1[MAXN], fac2[MAXN], inv[MAXN];
ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }

template <typename C, typename T = std::decay_t<decltype(*begin(std::declval<C>()))>, typename std::enable_if<!std::is_same<C, std::string>::value>::type* = nullptr>
std::ostream& operator<<(std::ostream& os, const C& container)
{
    bool first = true;
    std::stringstream ss;
    ss << '[';
    for (const auto& x : container)
    {
        if (!first)
        {
            ss << ", ";
        }
        first = false;
        ss << x;
    }
    ss << ']';
    return os << ss.str();
}
template <class T1, class T2>
std::ostream& operator<<(std::ostream& os, const std::pair<T1, T2>& p)
{
    os << '{' << p.first << ", " << p.second << '}';
    return os;
}
vector<string> vec_splitter(string S)
{
    S += ',';
    vector<string> res;
    while (!S.empty())
    {
        res.push_back(S.substr(0, S.find(',')));
        S = S.substr(S.find(',') + 1);
    }
    return res;
}

template <typename Head, typename... Tail>
void debug_out(vector<string> args, int idx, int LINE_NUM, Head H, Tail... T)
{
    if (idx > 0)
        cerr << ", ";
    else
        cerr << "Line(" << LINE_NUM << ") ";
    stringstream ss;
    ss << H;
    cerr << args[idx] << " = " << ss.str();
    debug_out(args, idx + 1, LINE_NUM, T...);
}
#ifdef DEBUG
#define debug(...) debug_out(vec_splitter(#__VA_ARGS__), 0, __LINE__, __VA_ARGS__)
#else
#define debug(...) 42
#endif


#define n 100
class stack {
    int* arr;
    int top;

public:
    stack() {
        arr = new int[n];
        top = -1;
    }
    void push(int x) {
        if (top == n - 1) {
            cout << "Stack Overflow" << endl;
            return;
        }
        top++;
        arr[top] = x;
    }
    void pop() {
        if (top == -1) {
            cout << "no element to pop" << endl;
            return;
        }
        top--;
    }
    int top() {
        if (top == -1) {
            cout << "No element in stack" << endl;
            return -1;
        }
        return arr[top];
    }
    bool empty(){
        return top == -1;
    }
};

//Reverse a sentence using stack
void reverseSentence(string s) {
    stack<string> st;
    for (int i = 0; i < s.length(); i++) {
        string word = "";
        while (s[i] != ' ' && i < s.length()) {
            word += s[i];
            i++;
        }
        st.push(word);
    }
    while (!st.empty()) {
        cout << st.top() << " ";
        st.pop();
    }cout << endl;
}

//Reverse a stack without using extra stack
void insertAtBottom(stack<int>& st, int ele) {
    if (st.empty()) {
        st.push(ele);
        return;
    }
    int topele = st.top();
    st.pop();
    insertAtBottom(st, ele);
}
void reverse(stack<int>& st) {
    if (st.empty()) return;
    int ele = st.top();
    st.pop();
    reverse(st);
    insertAtBottom(st, ele);
}

//Prefix expression evaluation
int prefixEvaluation(string s) {
    stack<int> st;
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s[i] >= '0' && s[i] <= '9') {
            st.push(s[i] - '0');
        }
        else {
            int op1 = st.top();
            st.pop();
            int op2 = st.top();
            st.pop();
            switch (s[i]) {
            case '+':
                st.push(op1 + op2);
                break;
            case '-':
                st.push(op1 - op2);
                break;
            case '*':
                st.push(op1 * op2);
                break;
            case '/':
                st.push(op1 / op2);
                break;
            case '^':
                st.push(pow(op1,op2));
                break;
            default:
                break;
            }
        }
    }
    return st.top();
}

//Postfix expression evaluation
int postfixEvaluation(string s) {
    stack<int> st;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] >= '0' && s[i] <= '9') {
            st.push(s[i] - '0');
        }
        else {
            int op2 = st.top();
            st.pop();
            int op1 = st.top();
            st.pop();
            switch (s[i]) {
            case '+':
                st.push(op1 + op2);
                break;
            case '-':
                st.push(op1 - op2);
                break;
            case '*':
                st.push(op1 * op2);
                break;
            case '/':
                st.push(op1 / op2);
                break;
            case '^':
                st.push(pow(op1, op2));
                break;
            default:
                break;
            }
        }
    }
    return st.top();
}

//Infix to Postfix
/*
* if operand: print
* if '(' :push to stack
* if ')' :pop from stack and print until '(' is found
* if operator : pop from stack and print until an operator
* with less precedence is found
*/
int prec(char c) {
    if (c == '^') return 3;
    else if (c == '*' || c == '/') return 2;
    else if (c == '+' || c == '-') return 1;
    else return -1;
}
string infixtoPostfix(string s) {
    stack<char> st;
    string res;
    for (int i = 0; i < s.length(); i++) {
        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {
            res += s[i];
        }
        else if (s[i] == '(') st.push(s[i]);
        else if (s[i] == ')') {
            while (!st.empty() && st.top() != '(') {
                res += st.top();
                st.pop();
            }
            if (!st.empty()) st.pop();
        }
        else {
            while (!st.empty() && prec(st.top()) > prec(s[i])) {
                res += st.top();
                st.pop();
            }
            st.push(s[i]);
        }
    }
    while (!st.empty()) {
        res += st.top();
        st.pop();
    }
    return res;
}

//Infix to Prefix
// trick: reverse the expression
// then traverse it converting '(' to ')' and ')' to '('
// then apply the infix-to-postfix algorithm
string infixtoPrefix(string s) {
    reverse(s.begin(), s.end());
    stack<char> st;
    string res;
    for (int i = 0; i < s.length(); i++) {
        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {
            res += s[i];
        }
        else if (s[i] == ')') st.push(s[i]);
        else if (s[i] == '(') {
            while (!st.empty() && st.top() != ')') {
                res += st.top();
                st.pop();
            }
            if (!st.empty()) st.pop();
        }
        else {
            while (!st.empty() && prec(st.top()) > prec(s[i])) {
                res += st.top();
                st.pop();
            }
            st.push(s[i]);
        }
    }
    while (!st.empty()) {
        res += st.top();
        st.pop();
    }
    reverse(res.begin(), res.end());
    return res;
}

//Balanced Parantheses
bool isValid(string s) {
    int n = s.size();
    stack<char> st;
    bool ans = true;
    for (int i = 0; i < n; i++) {
        if (s[i] == '(' || s[i] == '{' || s[i] == '[') {
            st.push(s[i]);
        }
        else if (s[i] == ')') {
            if (!st.empty() && st.top() == '(') st.pop();
            else {
                ans = false;
                break;
            }
        }
        else if (s[i] == ']') {
            if (!st.empty() && st.top() == '[') st.pop();
            else {
                ans = false;
                break;
            }
        }
        else if (s[i] == '}') {
            if (!st.empty() && st.top() == '{') st.pop();
            else {
                ans = false;
                break;
            }
        }
    }
    if (!st.empty()) return false;
    return ans;
}

#define FIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define test ll t; cin>>t; while(t--)
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    // freopen("input.txt","r",stdin); freopen("output.txt","w",stdout);
    
    return 0;
}
